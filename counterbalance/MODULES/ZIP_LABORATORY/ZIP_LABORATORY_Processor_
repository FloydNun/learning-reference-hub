#!/usr/bin/env python3
"""
ðŸ›¸ COUNTERBALANCE - ZIP_LABORATORY Processor
Extracts and manages ZIP files with diff/merge tools
- Extracts ZIPs to parallel subdirectories (NO OVERWRITE)
- Generates manifest and preview
- Enables comparison between extractions
- Integrates crawler and diff tools
"""

import sys
import os
from pathlib import Path
from datetime import datetime
import json
import zipfile
import shutil

# Add parent directories to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent. parent))

from Import_Header_Include import log_header, get_runtime, DEBUG
from Import_Footer_Include import log_footer, close_out
from Import_Globals_Include import *


class ZIPLaboratoryProcessor:
    """Processor for ZIP_LABORATORY module"""
    
    def __init__(self):
        self.script_name = "ZIP_LABORATORY_Processor.py"
        self. module_dir = Path(__file__).parent
        self.extractions_dir = self.module_dir / "extractions"
        self.manifests_dir = self.module_dir / ". manifests"
        
        # Create directories
        self. extractions_dir.mkdir(exist_ok=True)
        self.manifests_dir.mkdir(exist_ok=True)
        
        log_header(self.script_name, "ZIP_LABORATORY Processor initialized")
    
    def log_console(self, message:  str):
        """Log to console. log"""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        log_entry = f"[{timestamp}] [CONSOLE] [{self.script_name}] {message}\n"
        
        log_file = LOGS_DIR / "console.log"
        with open(log_file, 'a') as f:
            f.write(log_entry)
        
        if DEBUG:
            print(f"ðŸ”¬ LAB: {message}")
    
    def log_error(self, message: str):
        """Log to error.log"""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        log_entry = f"[{timestamp}] [ERROR] [{self.script_name}] {message}\n"
        
        log_file = LOGS_DIR / "error.log"
        with open(log_file, 'a') as f:
            f.write(log_entry)
        
        print(f"âŒ ERROR: {message}")
    
    def extract_zip(self, zip_path: Path) -> dict:
        """Extract ZIP to parallel subdirectory"""
        self.log_console(f"Extracting ZIP: {zip_path.name}")
        
        # Create unique extraction directory
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        extract_name = f"{zip_path.stem}_{timestamp}"
        extract_dir = self.extractions_dir / extract_name
        
        result = {
            'success': False,
            'extract_dir': None,
            'files':  [],
            'errors': []
        }
        
        try:
            # Validate ZIP
            if not zipfile.is_zipfile(zip_path):
                result['errors'].append("Not a valid ZIP file")
                self.log_error(f"Invalid ZIP:  {zip_path.name}")
                return result
            
            # Extract
            with zipfile.ZipFile(zip_path, 'r') as zip_ref:
                zip_ref.extractall(extract_dir)
            
            # Catalog extracted files
            for root, dirs, files in os. walk(extract_dir):
                for file in files:
                    file_path = Path(root) / file
                    rel_path = file_path.relative_to(extract_dir)
                    result['files'].append({
                        'path': str(rel_path),
                        'size': file_path.stat().st_size
                    })
            
            result['success'] = True
            result['extract_dir'] = str(extract_dir)
            self.log_console(f"Extracted {len(result['files'])} file(s) to:  {extract_name}")
            
        except Exception as e:
            result['errors']. append(str(e))
            self.log_error(f"Extraction failed: {e}")
        
        return result
    
    def create_manifest(self, zip_path: Path, extraction_result: dict) -> bool:
        """Create manifest for extraction"""
        self.log_console(f"Creating manifest for:  {zip_path.name}")
        
        try:
            manifest = {
                'zip_filename': zip_path.name,
                'extracted_at': datetime.now().isoformat(),
                'extract_dir': extraction_result['extract_dir'],
                'file_count': len(extraction_result['files']),
                'files': extraction_result['files'],
                'success': extraction_result['success'],
                'errors': extraction_result['errors']
            }
            
            manifest_file = self.manifests_dir / f"{Path(extraction_result['extract_dir']).name}.json"
            with open(manifest_file, 'w') as f:
                json.dump(manifest, f, indent=2)
            
            self.log_console(f"Manifest created: {manifest_file. name}")
            return True
            
        except Exception as e: 
            self.log_error(f"Failed to create manifest: {e}")
            return False
    
    def process_zip(self, zip_path: Path) -> bool:
        """Process a ZIP file"""
        self.log_console(f"Processing ZIP: {zip_path.name}")
        
        # Extract
        extraction_result = self.extract_zip(zip_path)
        
        if not extraction_result['success']: 
            self.log_error(f"Failed to extract:  {', '.join(extraction_result['errors'])}")
            return False
        
        # Create manifest
        if not self.create_manifest(zip_path, extraction_result):
            return False
        
        # Copy original ZIP to laboratory
        dest_path = self.module_dir / zip_path.name
        try:
            shutil.copy2(zip_path, dest_path)
            self.log_console(f"ZIP added to laboratory: {zip_path. name}")
            return True
        except Exception as e:
            self.log_error(f"Failed to copy ZIP: {e}")
            return False
    
    def list_extractions(self):
        """List all extractions with manifests"""
        self.log_console("Listing extractions")
        
        manifests = []
        for manifest_file in self.manifests_dir.glob("*.json"):
            try:
                with open(manifest_file, 'r') as f:
                    manifest = json.load(f)
                manifests.append(manifest)
            except Exception as e:
                self.log_error(f"Failed to read manifest:  {e}")
        
        if not manifests:
            print("\nðŸ”¬ ZIP_LABORATORY is empty\n")
            return
        
        print(f"\nðŸ”¬ ZIP_LABORATORY contains {len(manifests)} extraction(s):\n")
        
        for manifest in sorted(manifests, key=lambda x: x['extracted_at'], reverse=True):
            print(f"  ðŸ“¦ {manifest['zip_filename']}")
            print(f"     Extracted: {manifest['extracted_at'][: 10]}")
            print(f"     Files: {manifest['file_count']}")
            print(f"     Location: {manifest['extract_dir']}")
            print()


def main():
    """Main entry point"""
    processor = ZIPLaboratoryProcessor()
    
    try:
        processor.list_extractions()
        close_out("ZIP_LABORATORY_Processor. py", "SUCCESS")
    except Exception as e: 
        processor.log_error(f"Fatal error: {e}")
        close_out("ZIP_LABORATORY_Processor.py", "FAILURE")
        sys.exit(1)


if __name__ == "__main__":
    main()